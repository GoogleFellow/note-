# Minimal Version Selection
原文：https://research.swtch.com/vgo-mvs

作者：[Russ Cox](https://swtch.com/~rsc/)

翻译时间：2019-12-28

# 最小版本选择
（[Go 与版本](https://research.swtch.com/vgo)，第 4 部分）

发表时间：2018-02-21 周三 [PDF](https://research.swtch.com/vgo-repro.pdf)


# 译前名词解释
可暂时跳过本小节。

当正文中看到一些奇怪的名词时，再回头看看这里的解释：

- `build list`：译作 `构建列表`，表示一个软件构建时所依赖的包版本列表
- `requirement`：译作 `需求`，表示一个软件所依赖的包
- `build list`、`requirement`：后者表示一种需求，前者表示需求的一种具体形式
- `rough build list`：译作构建列表草稿，可认为是包含了一个模块的多个版本的构建列表，最终的构建列表将一个模块只取一个版本，即这些版本中的最新版
- `literal`：译作字面量，其实不是什么特殊含义，例如，有变量 `x = 1`，则 `-x = -1`，可认为 `x`、`-x` 都是字面量
- `clause`：译作子句，可简单理解为小括号括起来的部分式子。例如有这么一个式子 `(x1 OR x2) AND (x2 OR -x3)`，则式子有两个子句，分别是 `(x1 OR x2)` 和 `(x2 OR -x3)`。子句里面的是字面量，如此式子里的字面量是：`x1`、`x2`、`-x3`
- `manifest`：译作清单文件，指类似 Cargo 的 Cargo.toml、npm 的 package.json 文件，区别于 lock 文件；lock 文件是指类似 Cargo.lock、package-lock.json 文件




# 正文
[支持模块版本的 Go 命令](https://research.swtch.com/vgo-intro) 必须决定每次构建中所使用的模块版本。我将构建中所用到的模块、版本列表称为 `构建列表（build list）`。为了稳定开发，今天的构建列表必须也是明天的构建列表。但也应允许开发者修改构建列表：升级所有模块、只更新某个模块、只降级某个模块。

`版本选择` 的问题在于如何定义算法、如何使用算法实现在构建列表中的下面 4 个操作：

1. 构造当前的构建列表
2. 升级所有模块到最新版本
3. 仅升级 1 个模块到指定的新版本
4. 仅降级 1 个模块到指定的旧版本

最后 2 个操作是对 1 个模块进行升级或降级，但这样做可能需同时升级、降级、添加、删除其他模块。理想情况下，为满足模块依赖，将尽可能减少这种影响。

本文将介绍最小版本选择（minimal version selection）算法，这是解决版本选择问题的一个新的简单方法。最小版本选择很容易理解、预测，也更易于使用。这样做也能带来高保真的构建，即用户构建会尽量与作者开发时的构建一致。这样做还能高效地进行实现，只需一些图遍历的递归，不算复杂。所以在 Go 中实现最小版本选择只需几百行代码就能搞定。

最小版本选择假设每个模块都分别声明了其依赖需求：即一些其他模块的最小版本。假设每个模块的新版本号都遵循 [import 兼容性规则（import compatibility rule）](https://github.com/vikyd/note/blob/master/semantic_import_versioning.md)，所以新版本都兼容旧版本（译注：相同主版本号的前提下）。因此依赖需求中只需列明最小版本，永不使用最大版本，也不使用后续的不兼容版本列表（译注：不兼容版本列表可理解为不同主版本号的包是不兼容的）。

然后这 4 个操作可定义为：

1. 构造指定目标的构建列表时：首先构造目标自己的构建列表，然后加上每个依赖自己的构建列表（可理解为子依赖）。若一个模块在列表中出现了好几次，则选取其最新版。
2. 更新所有模块到最新版时：首先构造构建列表，但扫描一次每个依赖的构建列表，就像他们要更新到最新版本一样。
3. 更新一个指定模块到某个新版本：首先构造无任何版本升级的构建列表，然后再添加需更新的模块的构建列表。若一个模块在列表中出现了好几次，则选取其最新版。
4. 降级一个指定模块到某个旧版本：降级构建列表中的每个顶层依赖，直到不再指向比被降级模块更高的版本。

这些操作都是简单、高效的，而且也容易实现。



# 实例
在详细介绍最小版本选择前，我们先看下为什么这种方法很有必要。我们将用下图这些模块作为贯穿全文的例子：

![](https://research.swtch.com/version-select-1@2x.png)

（1 个虚线框对应 1 个模块）上图展示了 7 个模块分别的 1 个或多个版本。根据语义化版本（semver），每个模块的版本都对应相同的主版本号。我们开发了一个称为 A 1 的模块，并将运行一些命令来升级其所有依赖。上图展示了 A 1 目前的依赖，以及其他从 B 1 到 F 1 的各版本的依赖。

由于主版本号属于一个模块标识符（译注：如 go 的 import 路径结尾可带有的 /v2、/v3）的其中一部分，所以我们必须知道我们正在开发 A 1 而非 A 2，相反，若不指定 A 的任何精确版本，则说明我们还没发布 A。类似的，不同的主版本号就是不同的模块：B 1 与 B 2 就像与 C 1 一样没关系。我们甚至可以用 A 2 至 A 7 这些符号来表示 B 1 至 F 1，这样做虽然不影响上述例子的处理过程，但会变得很不直观。由于例子中所有模块的主版本号都是 1，所以从现在开始我们将尽可能忽略主版本号，譬如将 A 1 表示为 A。我们目前正在开发的 A 依赖于 B 1.2、C 1.2，而 B 1.2 又继续依赖 D 1.3。更早版本的 B 1.1 依赖了 D 1.1，等等。注意，F 1.1 依赖了 G 1.1，而 G 1.1 也依赖了 F 1.1。当单例的功能从一个模块转移到另一个模块时，这种循环依赖很有用，所以我们的算法也应能处理这种循环依赖。


# 低保真的构建
Go 目前的版本选择算法很简单，提供了 2 种不同的版本选择算法，但都不正确。

第 1 种算法是 `go get` 的默认行为：若你本地有一个版本，则使用此版本，或者下载使用最新的版本。这种模式使用的版本太老：若你已安装了 B 1.1，并执行 `go get` 下载，`go get` 不会更新到 B 1.2，从而可能因为 B 1.1 太老而导致构建失败或有 bug。

第 2 种算法是 `go get -u` 的行为：下载并使用所有模块的最新版本。这种模式可能会因为版本都太新而失败：若你运行 `go get -u` 来下载 A，会正确地更新到 B 1.2。同时也会更新到 C 1.3 和 E 1.3，但这可能不是 A 想要的，因为这些版本可能未经测试，所以可能难以正常工作。

我将基于这 2 种算法的构建称之为低保真构建（Low-Fidelity Builds）：虽然都想复现模块 A 的作者所使用的构建，但这些构建都因某些不明确的原因而变得有些偏差。在详细介绍最小版本选择算法后，我们将一探究竟为何最小版本选择算法可以产生高保真的构建。


# 算法
现在让我们来一起聊聊这种算法的更多细节。

## 算法 1：构造构建列表
有 2 种有用（且作用一样）的方法来构造构建列表：

- 基于递归
- 基于图遍历

基于递归的构建列表构造过程定义如下。首先构造一个空的构建列表草稿，将 M（译注：指递归过程中的某个模块）添加进去，并将 M 的每个依赖的子构建列表添加进去。然后构建列表草稿中只保留每个模块的最新版本，从而简化得到最终的构建列表。

![](https://research.swtch.com/version-select-list@2x.png)

这种通过递归来构造构建列表的方式主要用于帮助辅助理解。直接按照上述方式的实现是很低效的，对于无循环的图，可能计算时间会图的增大而快速增大；而对于循环依赖，则会陷入死循环。

为达到相同目的，基于图的可达性的方法会更高效。M 的构建列表草稿也即是所有可到达的模块列表，这些模块也即从 M 开始并沿着下图的箭头。构建列表草稿可通过普通的图递归遍历计算得到，只需避开已访问过的节点即可。例如，A 的构建列表草稿就是下图从 A 开始沿着高亮箭头的模块版本。

![](https://research.swtch.com/version-select-2@2x.png)

(同样的，从构建列表草稿简化为最终构建列表的方法不变，也即只要这些版本中的最新版本)

注意，此算法只对构建列表草稿中每个模块访问了 1 次，并且也只访问这些模块，所以执行时间与构建列表草稿的大小成正比 `|B|`，此外再加上必须遍历的箭头数量（最大为 `|B| 的平方`）。此算法完全忽略了构建列表草稿左侧的版本：例如，只加载了 D 1.3、D 1.4、E 1.2 的信息，并没加载 D 1.2、E 1.1、E 1.3 的相关信息。在依赖管理工具中，可能每个模块版本的信息都对应着一次网络请求，因此避开不必要的模块版本是一个重要的优化。


## 算法 2：升级所有模块
一次性升级所有模块可能是对构建列表最常见的修改，`go get -u` 就实现了这样的功能。

我们通过升级模块图中的所有依赖，并利用前面一节的算法进行计算，得到升级后的构建列表。升级后的模块需求图中，原来每个指向模块某个版本的箭头，现在都指向了每个模块的最新版本。（也可以从图中删除所有旧版本的模块，但构建列表的在构造时不会访问它们，所以也就无需对图进行清理）

例如，下图是升级所有模块版本后的需求图，黄色是原来的构建列表，红色标记是升级后的构建列表。

![](https://research.swtch.com/version-select-3@2x.png)

尽管上图告诉了我们升级后的构建列表结果，但并没有告诉我们构造的过程。为了升级需求图，我们修改了所有模块的需求，但在开发 A 的过程中进行升级时，应只记录在 A 的需求列表中（`go.mod` 文件中）。也即利用前面的算法 1 来产生我们想要的构建列表，即只选择红色标记的模块，而非黄色的。为了得到上述结果，需添加一些东西到 A 的需求列表中，因此我们引入了一个辅助算法 R。



## 算法 R：计算最小的需求列表
给定一个兼容模块需求图的构建列表时，我们想从中计算出一个包含构建列表的需求列表。我们可以列出构建列表中的每个模块，而非只列出目标本身。例如，上图中我们添加了 C 1.3（替换了 C 1.2）、D 1.4、E 1.3、F 1.1、G 1.1 到需求列表中。但一般来说，不是所有这些额外的模块都是必须的，我们想尽可能少的添加额外的模块。例如，F 1.1 代表了 G 1.1（反之亦然），所以我们无需同时列出这两者。乍一看，可能会很自然的从添加红色标记而非黄色标记的模块开始（存在于新列表中，不存在于旧列表中）。但这种方式会误删 D 1.4，因为它被旧的 C 1.2 依赖，而新的 C 1.3 不再依赖它了。

相反，正确的方式是，以反向后序的方式访问每个模块，也即先访问所有指向该模块的模块，之后再访问该模块，并仅添加未被已访问模块代表的模块。对于非循环图，结果是唯一的，即已添加的最小集合。对于循环图，反向后序遍历必须打破循环，并且已添加的集合是唯一的，并且对于未参与到循环中的模块来说是最小的。只要结果是正确且唯一的，我们就可以接受循环图中的结果是非最小的。在这个例子中，升级需要添加 C 1.3（替换了 C 1.2）、D 1.4、E 1.3，可以删除 F 1.1（C 1.3 代表了它）和 G 1.1（C 1.3 也代表了它）。



## 算法 3：升级 1 个模块
相比起一次性升级所有模块，谨慎的开发者可能只想升级其中一个模块，并尽量少修改构建列表。例如，当我们想升级到 C 1.3 时，我们并不想造成不必要的修改，如升级到 E 1.3。就像算法 2 那样，我们通过以下方式升级一个模块：升级需求图，从需求图（算法 1）中构造构建列表，然后将其简化为顶层模块（算法 R）的一系列需求。为了升级需求图，我们添加了一个新的箭头，从顶层模块指向被升级的模块版本。

![](https://research.swtch.com/version-select-4@2x.png)

和前面一样，新构建列表的模块标记为红色，旧的标记为黄色。


这种升级方式对于构建列表的影响是：这是升级的唯一的最小的方法，只添加了指定新模块版本及其实现的需求。注意，我们升级图时，必须只添加新箭头，而不要替换或删除任何旧的东西。例如，若从 A 至 C 1.3 的新箭头替换了从 A 至 C 1.2 的旧箭头，升级后的构建列表将会丢掉 D 1.4。也即是这种对 C 的升级将导致 D 的降级，这明显是预料之外的，且不是最小修改。一旦我们完成了构建列表的升级，就可运行前面的算法 R 来决定如何升级需求列表。这种情况下，我们最终将以 C 1.3 替换 C 1.2，但同时也会添加一个对 D 1.4 的新需求，以避免 D 的意外降级。注意，这种选择性升级只会升级其他模块到 C 的最小需求：C 的更新不会粗暴的拉取 C 的依赖模块的最新版本。


## 算法 4：降级 1 个模块
可能升级所有模块后，我们会发现某些模块的最新版本存储一些 bug，需要规避，此时我们就需要对某个模块降级到某个旧版本。降级一个模块，可能会导致降级其他模块，我们希望尽量少影响到其他模块。与升级某个模块类似，降级也必须通过修改目标的需求列表来对构建列表进行修改。与升级不同的是，降级必须移除某些需求，而不是仅仅添加需求。这样一来，降级的算法可以十分简单，只需单独考虑目标的每个需求。若某个需求与降级的模块不兼容，也即需求列表对应的构建列表中包含了一个现在不允许的版本，则只需继续尝试更旧的版本，直到找到与降级模块兼容的版本。

例如，继续从原始的构建图开始，假设 D 1.4 有 bug，实际是从 D 1.3 就开始引入这个 bug 了，所以我们想降级到 D 1.2。我们的目标模块 A 依赖了 B 1.2、C 1.2。为了从 D 1.4 降级到 D 1.2，我们需要找到不依赖（直接或间接）高于 D 1.2 的 B、C 的早期版本。

尽管我们可以对每个需求独立地进行分析，但从模块需求图整体出发的话会更高效。在我们的例子中，降级规则等同于删除 D 的不可用版本，然后根据箭头也需删除依赖这些不可用 D 的其他模块版本。最后，A 的需求列表的最新版本就可作为新的需求列表。

![](https://research.swtch.com/version-select-5@2x.png)

此时，降级到 D 1.2 表示也要降级到 B 1.1 和 C 1.1。为避免不必要地降级到 E 1.1，我们必须添加一个新的需求来依赖 E 1.2。我们可通过算法 R 来寻找新需求列表的最小集合来写进 `go.mod`。

注意，若我们先升级到 C 1.3，而再降级到 D 1.2 后将会继续使用 C 1.3，而 C 1.3 根本不依赖 D 的任何版本。但降级应只降级某些包，而不应升级任何包。若降级前需要先升级，用户必须明确自行操作（译注：即包管理器不应在背后自动升级某些模块）。


# 理论
最小版本选择算法是很简单的，它通过消除允许任意答案的灵活性来到达目的：构建列表就是需求列表中精确指定的版本。实际的系统需要更多灵活性，例如排除或替换某些模块版本。在添加这些灵活性之前，我们有必要研究一下当前系统简单性的理论基础，这样我们才知道哪种扩展能保持简单性，哪种不能。

如果你熟悉大多数其他系统的版本选择方式，或者你还记得我一年前 [Version SAT](https://github.com/vikyd/note/blob/master/version_sat.md) 的文章（译注：建议先看作者这篇文章，再往下看本文），则最小版本选择的最大特点可能是：它不能直接解决通用的 [布尔可满足性问题（Boolean satisfiability）](https://en.wikipedia.org/wiki/Boolean_satisfiability_problem)，或称 SAT 问题。正如我在较早前的文章中解释的那样，版本搜索几乎不需要直接解决 SAT；这些系统的版本搜索内部是非常错综复杂的，而且我们目前依然没有通用的解决办法。若要避免这些问题，我们需要知道边界在何处，在探索设计方案时不应走错方向。[舍费尔的二分法定理（Schaefer's Dichotomy Theorem）](https://en.wikipedia.org/wiki/Schaefer%27s_dichotomy_theorem) 刚好准确地描述了这些边界。它确定了：布尔公式的 6 个限制类可在多项式时间内决定可满足性问题。然后证明了对于超出上述公式中任一类情况的可满足性问题都是 NP 完全问题。为了避免 NP 完全问题，我们需要对版本选择进行限制，以保持在舍费尔的某一限制类之中。

事实证明，最小版本选择正好处于 6 个温顺的 SAT 子问题的其中 3 个的交集中：`2-SAT`、`Horn-SAT`、`Dual-Horn-SAT`。在布尔可满足性的式子中，一系列以 AND 连接的子句（clause）对应基于最小版本选择的构建，每个子句可以是以下 3 种的任意一种：

- 一个正值的字面量（表示此版本必须安装，如进行版本升级时）
- 一个负值的字面量（表示此版本不应安装，如进行版本降级时）
- 用 OR 连接的一个负值字面量和一个正值字面量（表示：如果已安装此版本，则还必须安装另一个版本）

最小版本选择的式子是一个 2-CNF 公式，因为每个子句最多包含 2 个变量。此式子同时也是一个 Horn 公式，因为每个子句最多包含 1 个正值字面量。此式子同时也是一个 dual-Horn 公式，因为每个子句最多包含 1 个负值字面量。也就是说，最小版本选择所暴露出来的每个可满足性问题都可以由上述 3 种不同的高效算法中的其中一种来解决，你喜欢用哪个都可以。就像我们前面所做那样，得益于更简单的数据结构，最小版本选择可在未来变得更简单也更高效。

尽管 2-SAT 已是 SAT 子问题中最著名的可高效解决的例子，但若这些问题同时也是 Horn 和 dual-Horn 式子时，将会变得更有意思。

- 每个 Horn 式子都有一个最少变量为 true 的唯一可满足性解。这说明，对于构造一个构建列表来说，以及对于每次版本升级来说，存在一个唯一的最小答案。在不必要时，唯一的最小版本升级，无需用到指定模块的更新版本。
- 反之，每个 dual-Horn 式子都有一个最少变量为 false 的唯一可满足性解。这也说明，对于每次版本降级来说，存在一个唯一的最小答案。在不必要时，唯一的最小版本降级无需用到指定模块的更老版本。

如果我们想将最小版本选择扩展到支持排除某些模块，我们只需继续遵循 Horn 和 dual-Horn 公式的约束，即可保持唯一性和最小性的优点。

【题外话：最小版本选择是一个 [NL 完全问题（NL-complete）](https://en.wikipedia.org/wiki/NL-complete)：它属于 NL 问题，因它是 2-SAT 的子集；它属于 NL 困难问题，因 st-connectivity 问题（译注：单向连通性问题）可轻松转换为最小版本选择中的构建列表的构造问题。我们很高兴已能将 NP 完全问题转化成了 NL 完全问题，但 NL 只保证了可在多项式时间内解决问题，这没什么实际意义，我们已经实现了一个线性时间内解决问题的方法。】



# 排除模块
最小版本选择通常会选择满足构建综合需求的最小（最旧）模块版本。若某个版本因为某些原因出 bug 了，升级或降级操作可通过修改顶层目标需求列表来强制选择不同的版本。

为避免在日后的升级或降级操作中重新引入 bug，我们应将有 bug 的版本明确地记录下来。但在这过程中，若想保持上一节说的唯一性和最小性，则需创建一些约束，这些约束必须同时是 Horn 和 dual-Horn 式子。这也就意味着这些构建的约束只能是：
- 无条件的正值断言：`X` 表示 `X` 必须安装
- 无条件的负值断言：`¬ Y` 表示不能安装 `Y`
- 正值的引申：`X → Z` 等效于 `¬ X ∨ Z`，表示若已安装 `X`，则 `Z` 也必须安装

而负值的引申（`X → ¬ Y` 等效于 `¬ X ∨ ¬ Y`，表示若已安装 `X`，则不能再安装 `Y`）不能作为其中的约束之一，因为它会打破式子。因此模块的排除必须是无条件的：必须与创建构建列表这事互相独立（译注：即先排除某些模块版本，再进行构建列表的创建）。

我们能做的是允许一个模块声明其 `局部` 需排除的模块版本。`局部` 的意思是指这个排除列表仅在构建该模块时才生效，若在以该模块作为其中一个依赖的更大项目的构建中，则该模块的排除列表不会生效。在我们前面的例子中，若 A（顶层模块）的构建会考虑 D 1.3 的排除列表，也就是说，选择 D 1.3 或 D 1.4 会导致可能不同的排除列表，也即排除列表变得有条件性，从而再次导致了 NP 完全的搜索问题。由于仅保证能将顶层模块构建成功，所以只能使用顶层模块的排除列表。注意，排除列表也可来源于网络的全局排除列表，前提是在构建之前就确定好排除列表，还有，排除列表不能依赖于构建时所选择的模块。

尽管一直在努力让排除变得无条件性，但好像我们又碰到了条件性的排除：C 1.2 依赖了 D 1.4，也即代表着会排除 D 1.3。不过我们的算法不会将这种情况认为 D 1.3 需被排除。当使用算法 1 时，会根据各自的最小需求将（B 依赖的）D 1.3 和 （C 依赖的）D 1.4 同时添加到构建列表草稿中。将构建列表草稿简化为最终的构建列表时，我们只会因为 D 1.4 已存在才删除 D 1.3（译注：而非因为排除而悄悄删除）。对兼容性和最小需求处理方式的不同，对于上述结果至关重要。

- 声明 C 1.2 必须不能与 D 1.3 一起构建，仅描述了何时会失败
- 声明 C 1.2 必须与 D 1.4 构建，仅描述了如何才能成功

排除列表至此已变得无条件性。尽管知道此事实很重要，但我们还未知如何实现排除列表。其中一种简单的做法是将排除列表作为构建的约束，如 `D 1.3 必须不能安装`。但问题来了，这样会导致如依赖了 D 1.3 的 B 1.2 也不能安装了。我们需要设置一种机制可让 B 1.2 还可以选择 D 1.4。实现此机制的一种简单方法是修改一下构建的约束条件，将 `B 1.2 → D 1.3` 修改为 `B 1.2 → D 1.3 ∨ D 1.4`，并允许使用 D 以后的新版本。此子句（等效于 `¬ B 1.2 ∨ D 1.3 ∨ D 1.4`）有 2 个正值，使得整个构建式子不再是 Horn 式子。但它依然是 dual-Horn 式子，所以我们仍可在线性时间内构造构建列表。但此时难以保证升级模块时继续拥有唯一、最小的答案，所以此问题需要解决。

实现模块排除时，我们可以改为仅修改已存在的模块，而非添加新的构建约束。也即，我们可像之前升级或降级模块时那样修改需求图。若某个模块被排除了，则我们可从模块需求图中将其删除，并将依赖该版本的模块转为依赖该模块的更新版本。例如，我们想排除 D 1.3，则我们可将 B 1.2 升级为依赖 D 1.4。

![](https://research.swtch.com/version-select-6.png)

若某个模块的最新版本被删除了，正如模块降级算法那样，则任意依赖该版本的模块都要被删除。例如如果 G 1.1 被删除了，则 C 1.3 也要被删除。

一旦模块排除被应用到模块需求图中后，则版本选择算法与之前的一致。


# 替换模块
假设在开发 A 的过程中，我们发现 D 1.4 中有 bug，并想测试一下可能的修复方式。我们需要在构建将 D 1.4 替换为一个未发布的副本 U。我们应允许一个模块声明 U 作为替代品：如对待 D 1.4 源码一样，并且在需求列表中以 U 代之。

类似于模块排除，模块替换可在预处理步骤中，通过修改模块需求图来实现，而非在处理图的算法中增加复杂度。依然类似于模块排除，模块替换列表也是模块 `局部` 的。A 的构建只会使用 A 的替换列表，而不会使用 B 1.2 或 C 1.2 或任何其他模块的替换列表。这样做可避免替换列表变得有条件性，从而导致难以在线性时间内实现。这样做还可以避免替换时可能的冲突：如果 B 1.2 和 C 1.2 为 E 1.2 指定了不同的替换，该怎么办？更通用来说，让模块排除、模块替换列表的作用范围保持在当前模块，可避免对依赖本模块的其他构建产生意外影响。


# 谁应控制你的构建
进行顶层构建时，应能对顶层模块所依赖的包进行一定程度的控制。B 1.2 应有权力去保证基于 D 1.3 或更新版本进行构建，而非 D 1.2。否则我们将又回到了老版 `go get` 的依赖失败模式中。

同时，构建应依然保持可预测性和可理解性，我们不能允许对顶层构建进行任意细粒度的随意控制，这会导致冲突和很多意外事情发生。例如，假设 B 依赖偶数版本的 D，C 依赖质数版本的 D。而 D 经常更新，已到了 D 1.99。若分别独立使用 B 和 C 时，可以使用相对接近最新版本的 D（如 D 1.98 或 D 1.97）。但当 A 同时使用了 B 和 C 后，构建时只能悄悄地选择很旧的 D 1.2。这是一个比较极端的例子，但问题是：是否该赋予 B 和 C 的作者对 A 进行如此极端的控制权限？当我写本文时，有一个 [公开的错误报告](https://github.com/kubernetes/client-go/issues/325)：Kubernetes 的 Go 客户端声明了一个需求，此需求依赖了一个 2 年前的旧版本 `gopkg.in/yaml.v2`。在使用了 Kubernets Go 客户端的程序中，开发者若想使用该 YAML 库的新功能，即使尝试升级到最新的可能的 YAML 库版本，也会导致使用了新功能的代码编译失败，因为所谓 `最新版本` 已被 Kubernetes 的需求限制了。在这种情况下，使用 2 年前的旧版 YAML 库，对于 Kubernetes 相关代码来说可能是完全合理没问题的，Kubernetes 的作者们也确实应该对他们的构建拥有完整的控制权限。但这种控制对于 Kubernetes 之外的开发者的构建来说没什么意义。

在设计模块的需求、排除、替换机制时，我试图在互相竞争的点中寻求平衡点，既应允许依赖拥有足够的控制来确保构建成功，又不应让依赖拥有太大的控制权限，以免对构建造成不良影响。最小需求可组合在一起而不会有冲突，所以可以很灵活（甚至很简单）地从所有依赖中收集到最小需求。但排除和替换机制可能会导致冲突，所以我们只允许在顶层模块指定排除和替换。

因此，当模块作为主程序构建时，模块作者可对其拥有完全的控制权限，但当模块作为别人构建的依赖项时，则模块作者不应拥有过多的控制权限。正因这种区别，我相信最小版本选择的机制可适用于比现有系统更大、更分布式的代码生态中。


# 高保真的构建
现在，我们再回到高保真构建的相关问题中。

正如在本文开头所看到的，使用 `go get` 来构建 A 时，所用到的依赖可能与 A 的作者所用的依赖不一致，并且你可能不知道问题出在哪里。我将此称为低保真的构建，因为这种情况很难复现 A 的原始构建结果。使用最小版本选择后，构建都是高保真的。模块的需求被保护在了模块的源码中，能唯一地指明如何直接构建。用户对 A 的构建是模块作者的构建的精确还原：一个可复现的构建。但高保真的构建还有更多含义。

可复现的构建通常被认为是一种是或否的属性，对于整个程序的构建来说：用户的构建与作者的构建要么一致，要么不一致。当一个模块是一个更大程序的一部分时，构建此库模块会发生什么样的事？若用户对库模块的构建能尽量与模块作者的构建一致当然最好，这样用户就可以运行与作者所开发、测试一致的代码（包括其依赖）。在更大的项目中，当然用户对库模块的构建有时不可能完全与作者的构建完全一致。大型项目中其他部分的构建可能使用了更新版本的依赖，使得用户的构建偏离了作者的构建。我们将这种为满足整个构建中其他部分的需求才有所偏离的构建称为：高保真的构建。

再次看看我们开头的例子：

![](https://research.swtch.com/version-select-1@2x.png)

在这个例子中，尽管 B 依赖了 D 1.3，A 的构建依然使用了 B 1.2、D 1.4。整个改变是必须的，因为 A 使用了 C 1.2，而 C 1.2 依赖了 D 1.4。A 的构建依然算是 B 1.2 的高保真构建：B 1.2 因被逼使用了 D 1.4 而导致构建有所偏离，且仅当必须时才这样做。相反，正如 `go get -u`、Dep、Cargo 通常的做法，若构建时使用了 E 1.3，则此构建属于低保真的构建：因为它进行了不必要的偏离。

最小版本选择通过选择需求中的最旧的可用版本来达到高保真的构建。依赖若发布了新版本，也不会影响到最小版本的构建。相反，大部分的其他系统，包括 Cargo、Dep 都使用了 `清单文件` 中的 [最新的可用依赖版本](https://research.swtch.com/cargo-newest.html)，依赖发布了新版本后会改变原始构建的结果。为了让构建可复现，这些系统引入了第二种机制，即 lock 文件，lock 文件中列明了每个依赖应使用的具体版本号。lock 文件保证了整个程序构建的可复现性，但却忽略了对于库模块的构建；[Cargo FAQ](http://doc.crates.io/faq.html#why-do-binaries-have-cargolock-in-version-control-but-not-libraries) 这样解释：准确来说，库模块不应追求所有用户对其构建都一致。Cargo 说得没错，完美的可复现构建并不是任何情况都可达到的，但 Cargo 完全放弃了库模块的可复现性，允许某些不必要的操作，从而偏离模块作者的构建，也就是说，这是一种低保真的构建。在我们的例子中，当 A 在构建中首次添加 B 1.2、C 1.2 时，Cargo 发现这些依赖需要 E 1.2 或更新的版本，并会采用 E 1.3。但是，除非另有说明，继续使用与 B 和 C 的作者所使用的 E 1.2 应是更好。使用允许的最旧版本可以消除同时拥有 2 个文件导致的冗余，冗余在于清单文件 和 lock 文件都分别指定了所需使用的模块版本。

自动使用更新的版本的机制会导致最小需求变得不正确。假设在开始时，A 依赖了 B 1.1，当时 B 1.1 是最新版本，我们记录为 A 仅依赖 B 1.1。过了一段时间，B 1.2 发布了，我们开始在 A 的构建使用 B 1.2，并记录到 lock 文件中，但此时不更新清单文件。此时，不再基于 B 1.1 来开发和测试 A。我们可能会用到 B 1.2 的新功能或对 bug 的修复，但现在 A 所列出的最小需求依然是 B 1.1，这是不正确的。如果用户总是选择更新的版本，而非选择最小需求，那倒也没太大问题：他们会依然使用 V 1.2。但当系统尝试去使用声明的最小需求时，问题就会出现。例如，当用户尝试对 A 进行有限的更新时，系统并不知道还需要更新到 B 1.2。更通用地说，不管最小版本（清单文件中）还是构建所使用的版本（lock 文件中）如何不同，我们凭什么去相信基于最小版本来构建可以得到没问题的库？为了探测这个问题，[Cargo 有开发者提议](https://github.com/rust-lang/cargo/issues/4100) `cargo publish` 来在发布前先尝试基于所有依赖的最小版本进行构建。此方法可探测到 A 使用了 B 1.2 的新功能时，基于 B 1.1 进行构建会失败；但探测不到：A 依赖了 B 1.2 对 B 1.1 的一些 bug 修复（译注：因为此时构建依然能成功）。

问题的根源在于，在版本选择期间允许使用更新的版本，从而导致了低保真的构建。lock 文件只是部分解决方案，目标是让整个程序能构建成功；还有类似 `cargo publish` 的额外构建检查也只是部分解决方案。更完全的方案应是使用模块作者构建时使用的版本。这可让用户的构建尽可能的与模块作者的构建一致，这才是高保真的构建。



# 升级速度
基于最小版本选择会使用每个依赖允许的最低版本，大家很容易会想到：这样可能会导致一直使用很旧的包版本，从而导致不必要的 bug 或安全问题。在实际操作中，我认为情况刚好相反，因为最小允许的版本正是所有约束的最大范围。所以，在构建中允许对所有模块进行控制（如强制使用依赖的某个更新版本）属于一种能力而非一种悄悄进行的动作。我希望使用最小版本选择的用户，他们的程序最终都可用得上新的依赖版本，就像他们的朋友所使用的更激进系统（如 Cargo）那样的新依赖版本。

例如，假设你正在写一个程序，此程序依赖了少量的其他模块，而且这些模块都依赖了一个很常见的模块，如 `gopkg.in/yaml.v2`。你的程序将会使用 `所有依赖` + `你程序所指定` 的 YAML 库中的最新版本。即使只有这么一个的依赖（译注：说的是 yaml 库），也会迫使你的构建去更新许多其他的依赖。这与我前面所提到的 Kubernetes Go 客户端问题的例子刚好相反。

如果说有什么区别的话，`最小的最大` 会导致依赖的版本更新得太快（译注：这里指的是类似 Cargo 的系统），而最小版本选择则不会。但我认为在实践中，最小版本选择的依赖的更新速度会是正常的，会比 Cargo 慢，但慢的差距刚好是 Cargo 太快的那部分。


# 升级时间
最小版本选择的一个关键特点是：若开发者不主动要求，则不会去升级依赖的版本。你不会被安装一个未经测试的模块版本，除非你主动去升级它。

举个例子，在 Cargo 中，若 B 依赖了 C 2.9，当你在构建中添加了 B，你通常不会得到 C 2.9。此时你会得到的是 [允许的最新版本](https://research.swtch.com/cargo-newest.html)，如 C 2.15。可能这个 C 2.15 才刚发布几分钟，模块作者可能还不知道其中是否有严重的 bug，因为未经大家使用验证。

再次明确一下，我不是在挑 Cargo 的刺，在我看来 Cargo 实质是一个设计良好的系统。这里我将 Cargo 作为模型的示例，是因为可能很多开发者对其比较熟悉，便于我去对比描述最小版本选择与它之间的不同之处。


# 最小
我之所以将此系统称为最小版本选择，是因为从整个系统来看已是最小的：在不破坏功能的前提下，我认为此系统中已不能再删除任何东西。有人会很肯定地说这系统已经删除太多东西了，但从我实践看来，已基本能完美满足实际应用场景了。我们将会在 `vgo` 原型中进行更多的试验。

最小版本选择的关键点是它更倾向于选择一个模块所允许的最小版本。我进行了下面 2 种方法对比：

- `go get -u`：将所有模块版本升级到最新版
- Cargo 的 `清单文件和 lock 文件`：基于系统的上下文，可依赖 [import 的兼容性规则](https://research.swtch.com/vgo-import)

对比后我发现，清单文件和 lock 文件都是为了同一个目的：为默认的行为 `升级所有模块版本到最新版` 能正常工作而努力。清单文件描述了 `不需要` 哪些更新的版本，lock 文件描述了 `不想要` 哪些更新的版本。因此，为什么不直接修改默认行为呢？应修改为：默认使用允许的最小版本，默认使用作者所使用的精确对应的版本，将升级的时机完全交给用户。这种方法可产生可复现的构建，并且无需 lock 文件，从而能形成高保真的构建，仅在必要时才去修改为偏离作者原始构建的版本。

最重要的是，我想找到一种易于理解的、可预测的、平淡无奇的版本选择算法。其他系统对于版本选择功能，想努力展示其原始灵活性和强大，相反，最小版本选择的目的在于让人们感觉不到它的存在，我希望最小版本选择能成功。
