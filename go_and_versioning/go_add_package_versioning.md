# Go += Package Versioning

原文：https://research.swtch.com/vgo-intro

作者：[Russ Cox](https://swtch.com/~rsc/)

翻译时间：2020-01-12

# Go += 包版本管理

（[Go 与版本管理](https://research.swtch.com/vgo)，第 1 部分）

发表时间：2018-02-20 周二 [PDF](https://research.swtch.com/vgo-intro.pdf)

# 译前名词解释

可暂时跳过本小节。

在正文中看到一些奇怪的名词时，再回头看看这里的解释：

- `build`：译作构建，可理解为 `go build` 这类动作
- `reproducible build`：译作可复现的构建，可理解为能用相同内容的依赖包进行的构建

# 正文

是时候为 Go 语言添加包版本管理功能了。

> 译注：准确说应是模块（module）的版本管理

更准确来说，我们需要将包版本的概念引入到 Go 语言开发者和我们的工具中，他们互相协作时才能更精准沟通，如：精确描述哪个程序应被构建、运行、分析。go 命令也应能让开发者精确知道在构建中使用了哪个包的哪个版本，反之亦然（译注：即开发者告诉 go 命令该如何做时）。

引入版本管理有助于保证可复现的构建，当我告诉你去使用我程序的最新版本时，我清楚知道你不仅将使用我最新版的代码，还将使用与我完全一致的所有依赖包，从而构建得到和我一样的二进制文件。

版本管理还有助于保证：今天构建的程序，明天再次构建时也能得到完全一样的结果。即使我的程序所依赖的包发布了新版本，go 命令也不应擅自去使用新版本的包，除非我主动要求。

虽然我们必须要添加版本管理，但也决不能丢弃目前 go 命令的一些优点：它十分简单、高效、易于理解。现在大部分开发者都不太关注版本管理，并且一切也都能基本正常运行。若此模式及其默认值是对的，那我们也应以类似的不干扰开发者的方式来增加版本管理功能，而同时让一切都变得更好、更容易理解。通常，版本相关的管理工作应在内部默默进行，而不应变成开发者每天都需关心的事。

简而言之，Go 语言需要增加包版本管理功能，但此过程中不能破坏原有的 `go get`。本文将简述实现此目的的一个提案，并提供一个原型工具 vgo。此原型工具现在就可使用，并可能成为最终 `go` 命令集成版本管理功能的基础（译注：从 2020 年看来已成事实）。我希望本文能作为高效讨论的开端，讨论哪些方案可行或不可行。基于此讨论，我将对提案和原型工具进行修改，然后提交为 [Go 语言官方的提案](https://golang.org/s/proposal)，并作为一个可选的功能集成到 Go 1.11 中。

本提案将在保持 `go get` 精华的同时，并：

- 添加可复现构建的机制
- 引入语义版本（semver）
- 删除 vendor 机制
- 逐步废弃 GOPATH 机制，并采用基于项目工作流的机制
- 为 `dep` 及更早工具提供平滑的过渡方案

也就是说，此提案目前仍处于初级阶段。若本文中描述的细节不正确，我们将花些时间去修复，之后才落地到 Go 的主发行版中。

# 背景

在描述提案之前，先介绍一下我们是如何发展到目前进展的。本小节可能会有些长，但以史为鉴，有助于理解本提案为什么会长这样。若你不想看那么啰嗦的故事，可跳过本小节直接阅读 [提案一节](#提案)，或直接体验 [vgo 原型工具](https://github.com/vikyd/note/blob/master/go_and_versioning/a_tour_of_versioned_go.md)。

## Makefile、goinstall、go get

早在 2009 年 11 月，最初的 Go 发布包只包含了：编译器、连接器和一些基本的库。你需要运行 `6g` 和 `6l` 命令去编译和连接你的程序，同时我们也提供了一些示例 makefile 文件。有个很小的工具 `gobuld` 封装了一些功能：对单一的包进行构建，并大部分情况下会输出一个对应的 makefile 文件。这明显是不够完善的，但我们还是把当时所拥有的东西发布出来，之后再与社区一起完善。

2010 年 02 月，我们发起了 [goinstall 提案](https://groups.google.com/forum/#!msg/golang-nuts/8JFwR3ESjjI/cy7qZzN7Lw4J)。这是一个新的、零配置的命令，用于从源码仓库（如 Bitbucket、Github）中下载包。`goinstall` 在当时引入了现在开发者已十分熟悉的包 import 路径规则。由于当时没多少第三方代码遵循此 import 规则，所以 `goinstall` 最初只能用于 import 标准库中的包。但开发者们很快就将他们各种不同命名模式的代码适配为兼容我们目前熟知的 import 路径规则。随着遵循此规则的 Go 包越来越多，逐渐形成了明朗的生态系统。

`goinstall` 也终结了 makefile 文件，即消除了用户在构建时五花八门的 makefile 所造成的复杂性。虽然偶尔会有些包作者，不能方便地在构建时生成一些代码，但此简化对于包用户来说非常重要：用户无需在构建之前安装包作者所使用的那套工具集。此简化对于工具链来说也很重要。makefile 文件以命令式的步骤对包进行编译；对于同一个包，若 makefile 各不一样，则像 `go vet` 或代码自动提示工具等的逆向工程也很难进行。由于 makefile 的参差不齐，即使已得到构建所需的正确依赖，也很难做到仅在必要时才对包进行重新构建。虽然有人会因为丢失了灵活性而反对这样的简化，但现在回头再看，利明显大于弊。

2011 年 12 月，[go 命令](https://groups.google.com/d/msg/golang-dev/8DNjlySemwI/-1CDvVX6QVcJ) 作为 Go 1 的其中一个预览部分被引入，以新的 `go get` 代替了旧的 `goinstall`。

总体而言，`go get` 算是革命性的进步：

- 允许 Go 的开发者方便地共享代码，和依赖他人的包进行构建
- 将构建系统的细节隔离在 `go` 命令内

但 `go get` 缺少版本管理的功能。在 [很早之前关于 goinstall 的讨论](https://groups.google.com/d/msg/golang-nuts/8JFwR3ESjjI/cy7qZzN7Lw4J) 中，我们已很明确知道，需要为版本管理做一些事。但遗憾的是，对于当时我们 Go 团队来说，还没想清楚要将版本管理做成什么样子。当 `go get` 请求一个包时，它总是拉取最新的代码，并将下载、更新等操作，交给如 Git、Mercurial 等的版本管理系统去做。`go get` 对包版本的忽略至少会导致 2 个明显的问题。

## 版本管理和 API 稳定性

`go get` 第 1 个明显的问题是：没有版本的概念时，它不能在包更新时明确告诉用户该以何种姿势应对更新带来的变化（译注：如：兼容性更新或不兼容性更新）。

2013 年 11 月，Go 1.2 的 FAQ 中增加了一条关于包版本管理的基本建议（此建议直到 Go 1.10 都没变过）：

> 发布到公共使用的包，在演进时应尽量保持向后兼容性（译注：如 v1.5 应兼容 v1.4）。[Go 1 的兼容性指南](https://golang.org/doc/go1compat.html) 就是一个很好的参考：不要移除已暴露的命名，鼓励使用组合单词来命名，等等。若需不同的功能，请创建一个新的命名，而非直接修改旧名字下的功能。若必须引入不兼容的修改，请创建一个新的包，并使用新的 import 路径。

2014 年 03 月，Gustavo Niemeyer 创建了 gopkg.in，倡议在 Go 语言中编写稳定的 API。此网站的可从 `go get` 的 URL 中解释出包的版本，并转发 GitHub 中对应版本的源码，如 `gopkg.in/yaml.v1`、`gopkg.in/yaml.v2` 分别对应 Git 仓库中的不同提交（也可能刚好是不同的分支）。基于语义的版本管理（semver），gopkg 希望包作者在引入不兼容性修改时创建一个新的主版本号，由于 `v2` 是完全不同的 API，所以 `v2` 的 import 路径可逐步替换 `v1` 的 import 路径（译注：因为二者可被同时使用）。

2015 年 08 月，Dave Cheney 提出了 [一个关于采用语义版本的提案](https://golang.org/issue/12302)。此提案引发了持续几个月的有趣讨论，几乎所有人都赞同为代码打上符合语义的版本 tag。但几乎没人知道下一步该做什么：工具链该如何应对这样的版本标识？

关于语义版本的任何讨论，必然会有根据 [Hyrum 定律（可称：海勒姆定律 或 隐式接口定律）](http://www.hyrumslaw.com/) 进行反对的观点，该定律为：

> 如果一个 API 拥有足够多的用户，那文档中约定的接口定义将不再重要：因为此时你系统的所有可观察行为都将变成由其他人来决定。

尽管从经验上来看 Hyrum 定律没错，但语义版本仍可对版本之间的关系约定一些预期结果。你所依赖的某个包从 1.2.3 更新到 1.2.4 时，不应导致你的代码运行失败，从 1.2.3 更新到 2.0.0 则不一定。若更新到 1.2.4 导致你的代码运行失败，则作者应在收到 bug 报告后进行修复，并发布为 1.2.5。若更新到 2.0.0 后导致你的代码运行失败（或编译失败），这很可能是作者故意的，因为可能此版本包含了重大修改，也不应期望你的代码不经过任何修改就能在依赖包更新到 2.0.1 后又恢复正常。

从 Hyrum 定律来看语义版本是不可能实现的，但我并不十分认同，我认为构建时应精确地使用与作者所使用的依赖版本一致的包，除非被强迫使用不一致的版本。也就是说，构建应尽量可被复现。

## vendor 模式和可复现的构建

`go get` 第 2 个明显的问题是：没有版本的概念时，它无法保证或描述如何复现一个构建。也就没有办法让你的用户使用与你同样版本的依赖包进行编译。2013 年 11 月，Go 1.2 的 FAQ 中添加了这条基本建议：

> 使用一个外部的依赖包时，你若担心该包无故发生变化，最简单粗暴的解决办法是复制一份到你的本地仓库（Google 内部也是使用这种方法）。将副本存储在一个新的 import 路径中，将其标识为本地副本。例如，你可将 `original.com/pkg` 复制为 `you.com/external/original.com/pkg`。Keith Rarick 写了一个名为 goven 的工具将此过程自动化。

`goven` 是 Keith Rarick 从 2012 年 03 月开始创建的，用于将 Go 的依赖包复制到你的仓库中，并更新包中的 import 路径为你仓库中的路径。此时，为了能让编译成功，在源码中修改 import 路径是不可避免的。但问题是，这种修改会导致这个包难以与其外部更新的版本进行对比，而且当你再复制其他依赖包进来时，若这些包也依赖了该包，则也需在这些包源码中修改引用该包的 import 路径。

2013 年 09 月，[Keith 发布了 godep](https://groups.google.com/d/msg/golang-nuts/8NJq6jTIpas/Vpf-KZtVu9MJ)，称为 `用于冻结包依赖的新工具`。godep 的主要进步是增加了我们现在所熟知的 vendor 目录的概念。godep 将依赖包复制到项目目录中，不修改依赖包的源码，而是通过对 go 原生工具链进行了封装（译注：如用 `godep go build` 替代 `go build`），能自动将项目中存放依赖包的相关目录也视为 GOPATH，从而编译成功。

2014 年 10 月，Keith 向 Go 工具链发出了 [增加对 `外部包` 支持的提案](https://groups.google.com/forum/#!msg/golang-dev/74zjMON9glU/dGhnoi2IMzsJ)，这样 go 命令就能更好的原生支持 godep 的机制。当时，也有多个与 godep 类似的工具出现。Matt Farina 写了一篇 [多如繁星的 Go 包管理器中的 Glide](https://codeengineered.com/blog/2014/glide-go-package-management/)，文中拿 godep 与其他新出现的包管理器进行了对比，特别是与 glide 的对比。

2015 年 04 月，Dave Cheney [发布了 gb](https://dave.cheney.net/2015/05/12/introducing-gb)。gb 是一个 `基于项目的构建工具 ... 可通过源码中的 vendor 机制得到可复现的构建`，而且也无需修改依赖包的 import 路径。（gb 的另一个目标是避免项目代码存储在 GOPATH 里，因为有些开发者的工作流与 GOPATH 机制不太兼容）

2015 年春，Jason Buberel 对 Go 的各种包管理器进行了调查，想对包管理器的各方面进行统一，避免不必要的重复工作。他的这个调查让我们 Go 团队意识到 go 命令应原生支持 vendor 机制，且不应修改 import 路径。与此同时，Daniel Theophanes 提出一种文件格式规范，用于精确描述 vendor 目录中依赖包的来源和版本。2015 年 06 月，我们采纳了 Keith 的提案，作为 [Go 1.5 的 vendor 实验](https://golang.org/s/go15vendor)，在 Go 1.5 是可选功能，在 Go 1.6 成为默认启用的功能。我们鼓励所有 vendor 相关工具的作者与 Daniel 一起制定一个元数据文件格式。

将 vendor 的概念整合到 Go 官方工具链中，可让程序分析工具如 `go vet` 对使用了 vendor 的项目进行更好的分析。如今，已有太多的 Go 包管理器或 vendor 工具，会导致 2 个问题：

- 不利于 `go vet` 之类的分析工具对采用 vendor 机制的源码进行分析
- 不利于互相合作和分享依赖需求信息，因元数据文件格式互不相同

从本质上来说，vendor 机制只是包版本管理问题的一个不完整的解决方案。它只提供了可复现的构建，但并未告诉大家包的版本是什么，以及该选择一个包的哪个版本作为构建使用。类似 glide 和 dep 的包管理器，在没有 Go 官方工具链支持的情况下，通过建立特殊的 vendor 目录，在 Go 的项目构建中隐式添加了版本概念。结果导致，Go 生态系统中很多工具都无法识别这些版本概念。这说明了，Go 应提供官方的工具链来支持包的版本管理。

## 官方的包管理器实验

在 GopherCon 2016 会议上，有一群有趣的 Go 爱好者在 Hack Day（现称为 Community Day）（译注：通常是正式会议之后一天的自由讨论）聚在一起 [对 Go 的包管理器进行了广泛的讨论](https://docs.google.com/document/d/1xMJ0c-YxvcgNglzjbALzncs5_Acr0MST29oMf9TkgQI/edit)。这次讨论的结果是：[成立一个包管理器工作委员会和一个讨论小组](https://groups.google.com/d/msg/go-package-management/P8TehVoFLjg/Ni6VRyOjEAAJ)，目标是创建一个新的 Go 包管理器工具。此工具的愿景是统一并替代目前 Go 的各种包管理器（译注：Go 有很多非官方的 [第三方包管理器](https://github.com/golang/go/wiki/PackageManagementTools)），继续使用 vendor 目录，但依然不属于 Go 官方工具链的原生功能。

此委员会的成员包括：

- 委员：Andrew Gerrand、Ed Muller、Jessie Frazelle、Sam Boyer
- 组织者：Peter Bourgon，起草了 [一份规范](https://docs.google.com/document/d/1qnmjwfMmvSCDaY4jxPmLAccaaUI5FfySNE90gB0pTKQ/edit)
- 实现者：Sam，带头将其实现为 [dep](https://github.com/golang/dep)

此委员会的背景可见于 Sam 的文章：

- 2016 年 02 月：[所以你想写一个包管理器](https://medium.com/@sdboyer/so-you-want-to-write-a-package-manager-4ae9c17d9527)
- 2016 年 12 月：[Go 的依赖管理传奇](https://blog.gopheracademy.com/advent-2016/saga-go-dependency-management/)
- 2017 年 07 月：GopherCon 会议上的演讲 [Go 包管理的新时代](https://www.youtube.com/watch?v=5LtMb090AZI)

dep 有几大作用：

- 它是今天为止可用的工具实践中的重要进步
- 它是朝一个解决方案前进的重要一步
- 它也是 `官方实验`，试验哪些功能对 Go 开发者有用或没用

但 dep 不是 go 命令中整合版本管理的直接原型。dep 是一个强大的、很灵活的工具，探索了包管理的设计空间，在我们争论着如何对 Go 程序进行构建时，扮演着类似 makefile 的角色。但当我们对包管理的设计空间了解得更深、明白到哪些关键特性必须实现后，我们才知道如何在 Go 生态系统中移除那些不必要的功能、灵活性。然后采取强制的约定，使得 Go 的代码库更统一、更易于理解、相关工具更易于构建。

本文算是 dep 之后的第一步：最终 go 命令集成版本管理的第一版草案原型，类似于之前的 `goinstall` 那样扮演原型角色。这个原型是一个独立的命令，名为 vgo。vgo 是一个拿来即用的可临时替代 go 命令的工具，不同的是 vgo 增加了对包版本管理的支持。这是一个新的实验，我们想看看能从中得到哪些收获。正如我们之前引入 `goinstall` 那样，现在已有一些代码和项目可在 vgo 下运行，但其他项目则需进行一些修改才能兼容。就像我们移除 makefile 那样，我们将移除一些控制权限和灵活性，来简化系统设计、减轻用户使用复杂度。总的来说，我们希望能找到一些尝鲜的用户来适配 vgo，帮助我们体验 vgo，这样我们就可以从中得到更多反馈。

开始 vgo 实验，并不代表立即结束 dep。在将版本管理功能正式集成到 go 命令之前（包括找到完整的路线、决定具体策略、实现功能，甚至可提供使用），我们将继续维护 dep。我们后面还会提供从 dep 过渡到带版本管理功能的 go 命令的相关工具，形式未定，但将尽可能平滑过渡。即使是那些未从其他包管理工具迁移到 dep 的项目也可参考 dep 的过渡方案（注意：[godep](https://github.com/tools/godep) 和 [glide](https://github.com/Masterminds/glide) 都已停止维护，并建议迁移到 dep）。若 vgo 已能满足需求，其他项目也可直接迁移到 vgo。

# 提案

关于将版本管理功能添加到 go 命令的提案有 4 个步骤：

第一，根据 Go FAQ 和 gopkg.in 的启发，采用 `import 兼容性规则`；并约定：拥有相同 import 路径的新版本包应向后兼容旧版本。

第二，在构建中，采用 `最小版本选择` 这样一个简单的新算法来决定该使用包的哪些版本。

第三，引入 Go 模块（module）的概念，表示一系列包在版本化后组成的一个单元，并声明其依赖必须满足的最小需求（译注：可理解为 go.mod）。

第四，定义如何将上述几点集成到原有的 go 命令中，且不大改原来的基础工作流。

本节后面部分将逐一介绍这几个步骤，而本周将发布其他文章来详述各步骤的细节。

## import 兼容性规则

几乎所有包管理器的痛点都是来源于对不兼容性问题的妥协。例如，大部分系统允许包 B 声明它依赖了 D 6 或更新版本，也允许包 C 声明它只可依赖 D 2、3、4 但不能是 D 5 或更新版本。假设你正在写一个包 A，若你想同时使用 B 和 C，那很不幸：不存在这样一个版本的 D 可同时满足 B 和 C，因此 A 不能构建成功。而且你无法改善此问题，因为那些包管理器都认为：B 和 C 都没做错，并鼓励 B 和 C 那样做。但问题就是，你确实卡住无法继续开发 A 了。

为了避免再设计出这种会导致大型程序无法构建的包管理器，本提案要求包作者遵循以下 import 兼容性规则：

> 若一个包的旧版本和新版本拥有同样的 import 路径，则新版本的包必须向后兼容旧版本的包。

此规则是对早之前 Go FAQ 其中一项建议的重述。Go FAQ 的该项建议最后提到：若不得已不能向后兼容，则应创建一个拥有新 import 路径的新包。现在的开发者大多希望用语义版本（semver）来表示不兼容的版本，所以我们也将语义版本引入到提案中。譬如，主版本号为 2 或更新的版本可在 import 路径中表示为类似下面的路径：

```go
import "github.com/go-yaml/yaml/v2"
```

根据 import 兼容性规则，从语义版本角度看，v2.0.0 引入了重要的不兼容修改，因此应创建一个新 import 路径的包。由于每个不同主版本号的包拥有不同的 import 路径，所以一个 Go 可执行程序中可同时包含多个不同主版本号的包。这是符合预期的，也是大家想要的结果。因为这种方式终于可按需对程序进行构建，也允许大型程序独立地从依赖包 v1 升级到 v2。

默认模块作者会遵循 import 兼容性规则，可避免使用各种小技巧来妥协不兼容性问题导致的额外问题，也可让整个包管理系统变得更简单、整个包生态系统更少碎片化。实际应用中，不管模块作者如何努力，总会有些同一主版本内的更新偶尔引入不兼容性修改，导致用户的构建失败。因此，应建立一个更新机制，让更新不要太快。这个问题很重要，下一小节我们将介绍这样的机制。

## 最小版本选择

目前几乎所有包管理器（包括 dep 和 cargo），在构建中都使用了 [允许的最新依赖版本](https://research.swtch.com/cargo-newest.html)。我认为这是一个错误的默认设置，原因有二：

- `允许的最新版本` 所代表的内容会因为外部的事件而变化，譬如某个依赖发布了新版本。可能你今天引入了某个依赖的最新版本，但明天同样的构建命令却得出不一样的构建结果，
- 为了覆盖默认值，开发者还需花些时间去告诉包管理器 `不要使用某个版本`，然后包管理器可能需花费很大的时间复杂度去 [搜索一种组合来满足 `不使用某个版本`](https://github.com/vikyd/note/blob/master/go_and_versioning/version_sat.md)。

本提案将使用截然不同的方式，我将这种方式称为 `最小版本选择`（minimal version selection）。默认情况下，它将在构建中使用每个依赖包的 `允许的最小版本`。使用这种方式，明天的构建不会与今天的构建不同，因为明天不会发布更旧的版本。而且，在覆盖默认值时，开发者花时间去告诉包管理器 `使用不低于 Y 的版本吧` 后，包管理器可在很低时间复杂度内知道该使用哪些版本进行构建。我将此方式称为最小版本选择的原因在于，当所选择的版本是允许的最小版本时（甚至此时整个系统的所有依赖的版本也几乎最小的），可避免现有其他包管理器的各种复杂度。

最小版本选择允许一个模块只指定其所依赖的其他模块的最小需求。此方式还可为升级版本或降级版本操作提供明确的、唯一的选择。此方式还可让综合模块的作者为构建指定以下动作：

- `排除` 某个依赖的某个版本
- 用其他包 `替换` 某个依赖的某个版本
  - 这个包可以是本地文件系统或自行发布的模块

当此其他模块依赖本模块进行构建时，这些 `排除` 和 `替换` 不会生效。如此一来，模块作者可对其自身模块的构建拥有完整的控制权限，且不影响别人程序的构建。

最小版本选择默认情况下无需 lock 文件即可得到可复现的构建。

最小版本选择之所以可以如此简单，其关键点在于 import 兼容性。用户可以说 `依赖的版本太老了`，而无需说 `依赖的版本太新了`，此时解决方案就很明确了：使用更新（最小）的版本吧，并且新的版本替换旧版本是没问题的。

## 定义 Go 模块

一个 Go 模块（module）是指拥有相同 import 路径的一系列包（package）的集合，这个 import 路径也称为模块路径。模块是版本管理的最小单元，模块的版本号是一个符合语义版规则本的字符串。基于 Git 进行开发时，开发者通常会在模块的 Git 仓库添加一个 tag 来定义模块的一个新语义版本号。虽然我们强烈建议使用语义版本，但也会支持以 commit 号作为版本。

模块中有一个名为 `go.mod` 的新文件，此文件定义了该模块对其他模块所依赖的最小版本需求。例如，这是一个 `go.mod` 文件的内容：

```
// My hello, world.

module "rsc.io/hello"

require (
	"golang.org/x/text" v0.0.0-20180208041248-4e4a3210bb54
	"rsc.io/quote" v1.5.2
)
```

此文件定义了一个模块路径为 `rsc.io/hello` 的模块，并列出了此模块所依赖的另外 2 个模块：`golang.org/x/text`、`rsc.io/quote`。对此模块进行构建时，会使用 `go.mod` 文件中所列出的依赖版本。若此模块被用作更大项目的一部分时，只有在此大项目的其他模块也使用了这些依赖的更新版本时，此模块才会使用依赖中的更新版本。

我们建议模块作者应使用语义版本号作为 tag 名，而且 vgo 也推荐使用基于 tag 的版本。模块 `rsc.io/quote`，其源码来自于 `github.com/rsc/quote`，就拥有一个名为 v1.5.2 的 tag 版本。而 `golang.org/x/text` 则没有提供基于 tag 的版本。为了标识未打 tag 的 commit，可用 `v0.0.0-yyyymmddhhmmss-commit` 这样的伪版本号形式来表示在特定日期的某个 commit。从语义版本角度来看，`v0.0.0` 表示预发布版本，并带有一个预发布的标识 `yyyymmddhhmmss-commit`。语义版本号排序时，会将该伪版本号排在 v0.0.0 或更新的版本之前；若有多个伪版本号，则按日期先后顺序，这就是为什么将 `yyyymmddhhmmss` 放在 `commit` 之前的原因。

`go.mod` 除了可用于指定需求列表外，如前面小节提到的，还可用于指定想排除或替换的依赖版本。但 `排除` 和 `替换` 仅在直接构建当前模块时有效，在更大项目构建时不会生效，详细可见这个 [例子](https://github.com/vikyd/note/blob/master/go_and_versioning/a_tour_of_versioned_go.md)。

`goinstall` 和旧式的 `go get` ，会基于类似 git、hg 的版本控制工具来下载源码。这会导致很多问题，例如：若用户没安装 bzr 工具的话，就下载不了来自 [Bazaar](https://bazaar.canonical.com/) 仓库的源码。相反，模块通常是一个 zip 包，可通过 HTTP 简单下载。在此之前，`go get` 需为流行的各代码托管网站选择不同的版本管理命令。而现在，vgo 只需通过不同网站的 API 获取源码包即可。

以 zip 包的形式来作为模块的统一表示方式，可实现一个轻量级的模块下载代理协议。各公司或个人均可以任何理由搭建自己的模块代理服务，如：

- 安全考虑（译注：防止泄露 import 路径或模块使用情况的统计数据等）
- 对模块源码进行缓存以避免外网依赖模块删除时找不到依赖。

有了模块代理服务和 go.mod 文件（可定义所需使用的依赖代码）后，可以不再需要 vendor 目录了（译注：也即无需靠 vendor 机制来保证可复现的构建）。

## 集成到 go 命令

我们应升级 go 命令，以便更好地支持模块功能。其中一个重要变化是，常用的构建命令如 `go build`、`go install`、`go run`、`go test` 等将可按需自动识别和下载所依赖的源码。例如，若想在模块中使用 `golang.org/x/text`，只需在 Go 代码中添加此 import 路径，并执行构建即可（译注：如直接执行 `go build` 即可自动识别和下载所依赖的源码）。

然而，最重要的变化是终于可以在开发 Go 项目时抛弃 GOPATH 了。因为 `go.mod` 文件：

- 已包含了当前模块的完整模块路径
- 已指定了所需的每个依赖的具体版本号
- 拥有 `go.mod` 文件的目录可明确被识别为一个项目的根目录，从而与其他目录区分开来

现在，你只需 `git clone`、`cd`，然后就可以立即开始正式工作了。不管怎样，GOPATH 已是过去式。

# 下一步？

我已写过一篇名为 [Go 的版本管理之旅](https://github.com/vikyd/note/blob/master/go_and_versioning/a_tour_of_versioned_go.md) 的文章，里面详细介绍了如何一步步使用 vgo，你现在就可下载和体验 vgo。我将在接下来的这个星期发表更多在本文未详说的细节。我希望在本文或后面的文章的评论区中收到大家的使用反馈，同时，我还会持续关注 Reddit 网站中的 Go subreddit 子话题，以及 golang-nuts 的邮件列表。星期五时，我就将会发表一篇 FAQ 作为本系列文章的终章（至少目前是这么想的）。下周，我将提交一份正式 Go 提案。

现在就开始试用 [vgo](https://github.com/vikyd/note/blob/master/go_and_versioning/a_tour_of_versioned_go.md) 吧：

- 在你的代码仓库添加 tag 版本
- 创建一个 `go.mod` 文件
- 注意：若你的项目内有一个空的 `go.mod` 文件，并且此项目也包含了一个 dep、glide、glock、godep、godeps、govend、govendor 或 gvt 的配置文件，vgo 会自动识别并转换到 `go.mod` 文件中

在经过漫长的等待后，我很高兴 Go 终于准备正式加入版本控制功能。在使用 Go 的过程中，大部分开发者碰到的最常见问题是：

- 不能得到可复现的构建
- `go get` 完全忽略 Git 的 tag
- GOPATH 中不能同时存在一个包的不同版本
- 需要在 GOPATH 外存放项目代码

本文所提供的方案可解决这些问题，以及一些其他的问题。

即使这样，我也知道本文的设计方案肯定会有错漏的地方。我希望我们的用户能在体验 vgo 过程中给我们提帮助建议，也希望能进行有效的讨论。我将在 Go 1.11 中以技术预览版的形式初步加入 Go 模块功能，在 Go 1.12 转为正式功能。在未来的 Go 版本中，我们可能会移除旧版的、不含版本管理功能的 `go get`。这是一个激进的计划，但若能真正得到正确的版本管理功能，即使继续迭代几个 Go 版本，我们认为也值得。

我会十分认真地考虑如何平滑地将旧版的 `go get` 和众多的 vendor 工具迁移到新的模块系统中。这个过程与如何正确实现版本管理功能同等重要。若能成功迁移，那即使再需几个 Go 版本的时间，我们认为也值得。

感谢 Peter Bourgon、Jess Frazelle、Andrew Gerrand、Ed Mueller、Sam Boyer，感谢他们在包管理委员会的工作，以及过去一年来提供了很多有用的讨论。

感谢 Dave Cheney、Gustavo Niemeyer、Keith Rarick、Daniel Theophanes，感谢他们在 Go 和包版本管理的发展历程上做出重要贡献。

感谢 Sam Boyer 创建了 dep，以及 dep 的所有贡献者的工作。

也感谢曾创建各种 vendor 工具的开发者。

最后也感谢帮助我们推动本提案前进的各位，感谢你们帮助发现、改进问题，让 Go 增加包版本管理功能的过程变得更畅顺。
